<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>IPA Signer — Direct GitHub API Client</title>
  <style>
    body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, sans-serif; padding: 24px; max-width: 820px; margin: auto; }
    input, button { padding: 10px; font-size: 16px; margin: 6px 0; width: 100%; box-sizing: border-box; }
    pre { background:#f4f4f4; padding:12px; border-radius:8px; overflow:auto; white-space: pre-wrap; }
    .small { font-size:13px; color:#666; }
    .result { background:#e8f5e8; border-left:4px solid #4caf50; padding:12px; margin:12px 0; }
    .error { background:#ffebee; border-left:4px solid #f44336; padding:12px; margin:12px 0; }
  </style>
</head>
<body>
  <h1>IPA Signer — Direct GitHub API Client</h1>
  <p class="small">Paste a PAT (repo scope) only into the PAT variable in your local browser. This client will create <code>incoming/&lt;uuid&gt;.txt</code> in <strong>SuperGamer474/IPA-Signer</strong>, then poll Actions and extract the result.</p>

  <label>URL to upload:</label>
  <input id="url" placeholder="https://example.com">

  <button id="btn">Upload URL (create incoming/&lt;uuid&gt;.txt)</button>

  <h3>Status</h3>
  <pre id="log">idle</pre>

  <div id="result" style="display:none;">
    <h3>Processing Result</h3>
    <pre id="result-content"></pre>
  </div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js" integrity="sha512-XMVd28F1oH/O71fzwBnV7HucLxVwtxf26XV8P4wPk26EDxuGZ91N8bsOttmnomcCD3CS5ZMRL50H0GgOHvegtg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script>
// ---- FIXED VARIABLES ----
const owner = "SuperGamer474";
const repo = "IPA-Signer";
const branch = "main";
const pat = "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";

// ---- LOGGING & HELPERS ----
const logEl = document.getElementById('log');
const resultEl = document.getElementById('result');
const resultContentEl = document.getElementById('result-content');
function log(...t){ logEl.textContent += "\n" + t.join(' '); logEl.scrollTop = logEl.scrollHeight; }
function base64EncodeUnicode(str){ return btoa(unescape(encodeURIComponent(str))); }

// ---- GITHUB API FUNCTIONS ----
async function createFile(owner, repo, branch, path, message, content_b64, pat) {
  const url = `https://api.github.com/repos/${owner}/${repo}/contents/${encodeURIComponent(path)}`;
  const body = { message, content: content_b64, branch };
  const resp = await fetch(url, { method:'PUT', headers:{'Authorization':'Bearer '+pat,'Accept':'application/vnd.github+json','Content-Type':'application/json'}, body:JSON.stringify(body) });
  if(!resp.ok){ const txt = await resp.text(); throw new Error(`Create file failed: ${resp.status} ${txt}`); }
  return resp.json();
}
async function listRuns(owner, repo, pat){
  const r = await fetch(`https://api.github.com/repos/${owner}/${repo}/actions/runs?per_page=50`, { headers:{'Authorization':'Bearer '+pat,'Accept':'application/vnd.github+json'} });
  if(!r.ok) throw new Error('List runs failed: '+r.status);
  return r.json();
}
async function findRunForCommit(owner, repo, commitSha, pat){
  for(let i=0;i<120;i++){
    log(`Searching for run for commit ${commitSha} (try ${i+1})...`);
    const j = await listRuns(owner, repo, pat);
    if(j.workflow_runs){ const found = j.workflow_runs.find(run => run.head_sha===commitSha); if(found) return found; }
    await new Promise(s=>setTimeout(s,3000));
  }
  throw new Error('Timeout waiting for workflow run to appear.');
}
async function waitForRunComplete(owner, repo, runId, pat){
  for(let i=0;i<200;i++){
    const r = await fetch(`https://api.github.com/repos/${owner}/${repo}/actions/runs/${runId}`, { headers:{'Authorization':'Bearer '+pat,'Accept':'application/vnd.github+json'} });
    if(!r.ok) throw new Error('Failed to fetch run status: '+r.status);
    const j = await r.json();
    log(`Run ${runId} status=${j.status} conclusion=${j.conclusion}`);
    if(j.status==='completed') return j;
    await new Promise(s=>setTimeout(s,3000));
  }
  throw new Error('Timeout waiting for run completion.');
}
async function getArtifactsForRun(owner, repo, runId, pat){
  const r = await fetch(`https://api.github.com/repos/${owner}/${repo}/actions/runs/${runId}/artifacts`, { headers:{'Authorization':'Bearer '+pat,'Accept':'application/vnd.github+json'} });
  if(!r.ok) throw new Error('Failed to list artifacts: '+r.status);
  return r.json();
}
async function downloadArtifactZip(owner, repo, artifactId, pat){
  const r = await fetch(`https://api.github.com/repos/${owner}/${repo}/actions/artifacts/${artifactId}/zip`, { headers:{'Authorization':'Bearer '+pat,'Accept':'application/vnd.github+json'} });
  if(!r.ok){ const txt = await r.text(); throw new Error('Download artifact failed: '+r.status+' - '+txt); }
  return r.blob();
}
async function extractTextFromZip(blob, uuid){
  return new Promise((resolve,reject)=>{
    const reader = new FileReader();
    reader.onload=function(e){
      try{
        const zip = new JSZip();
        zip.loadAsync(e.target.result).then(contents=>{
          let file = contents.file(`${uuid}-output.txt`);
          if(!file){
            const txtFiles = Object.keys(contents.files).filter(name=>name.endsWith('.txt')&&!contents.files[name].dir);
            if(txtFiles.length===0) reject(new Error('No text files found in artifact'));
            file = contents.file(txtFiles[0]);
          }
          file.async('text').then(resolve).catch(reject);
        }).catch(reject);
      }catch(err){ reject(err); }
    };
    reader.onerror=reject;
    reader.readAsArrayBuffer(blob);
  });
}

// ---- BUTTON HANDLER ----
document.getElementById('btn').addEventListener('click', async ()=>{
  logEl.textContent=''; resultEl.style.display='none';
  try{
    const urlInput = document.getElementById('url').value.trim();
    if(!urlInput){ alert('Enter a URL!'); return; }

    const uuid = (crypto.randomUUID?crypto.randomUUID():(Date.now().toString(36)+Math.random().toString(36).slice(2,8)));
    log('UUID:', uuid);

    const path = `incoming/${uuid}.txt`;
    const content_b64 = base64EncodeUnicode(urlInput);
    log('Creating file', path, 'on branch', branch);
    const createResp = await createFile(owner, repo, branch, path, uuid, content_b64, pat);
    const commitSha = createResp.commit?.sha;
    log('Created file. commit sha:', commitSha);

    log('Waiting for Actions workflow run for the commit...');
    const run = await findRunForCommit(owner, repo, commitSha, pat);
    log('Found run id', run.id, 'workflow:', run.name);

    const completedRun = await waitForRunComplete(owner, repo, run.id, pat);
    log('Run completed. conclusion:', completedRun.conclusion);

    const arts = await getArtifactsForRun(owner, repo, run.id, pat);
    if(!arts.artifacts?.length) throw new Error('No artifacts found for run.');
    log('Artifacts found:', arts.artifacts.map(a=>`${a.id}:${a.name}`).join(', '));

    const artifact = arts.artifacts.find(a=>a.name==='outputs')||arts.artifacts[0];
    log('Downloading artifact id', artifact.id, 'name', artifact.name);
    const blob = await downloadArtifactZip(owner, repo, artifact.id, pat);
    
    log('Extracting text content from zip...');
    const textContent = await extractTextFromZip(blob, uuid);

    resultContentEl.textContent=textContent;
    resultEl.style.display='block'; resultEl.className='result';
    log('Processing complete! Result displayed below.');

  }catch(err){
    log('ERROR:', err.message||err);
    resultContentEl.textContent='Error: '+(err.message||err);
    resultEl.style.display='block'; resultEl.className='error';
    console.error(err);
  }
});
</script>
</body>
</html>
